<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced AI Image Enhancer</title>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <style>
    :root {
      --bg-color: #121212; --surface-color: #1e1e1e; --primary-color: #03dac6;
      --on-primary-color: #000000; --text-color: #e0e0e0; --border-color: #333333;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--bg-color); color: var(--text-color); margin: 0;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      min-height: 100vh; padding: 20px; box-sizing: border-box;
    }
    h1 { color: var(--primary-color); text-align: center; }
    .container {
      width: 100%; max-width: 900px; background-color: var(--surface-color);
      border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      padding: 2rem; box-sizing: border-box;
    }
    .app-state { display: none; }
    body.state-loading #loadingState, body.state-upload #uploadState,
    body.state-pre-process #preProcessState, body.state-processing #processingState,
    body.state-results #resultsState { display: block; }
    #loadingState, #processingState { text-align: center; }
    .spinner {
        border: 4px solid rgba(255, 255, 255, 0.2); border-left-color: var(--primary-color);
        border-radius: 50%; width: 40px; height: 40px;
        animation: spin 1s linear infinite; margin: 20px auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #drop-area {
      border: 2px dashed var(--border-color); border-radius: 8px; padding: 40px;
      text-align: center; transition: background-color 0.2s, border-color 0.2s; cursor: pointer;
    }
    #drop-area.highlight { background-color: rgba(3, 218, 198, 0.1); border-color: var(--primary-color); }
    #drop-area p { margin: 0; font-size: 1.2rem; }
    .btn {
      display: inline-block; background-color: var(--primary-color); color: var(--on-primary-color);
      padding: 12px 24px; border-radius: 6px; border: none; font-weight: bold;
      margin-top: 20px; cursor: pointer; transition: opacity 0.2s;
    }
    .btn:hover { opacity: 0.9; }
    #fileElem { display: none; }
    #progressBarContainer { width: 100%; background-color: var(--border-color); border-radius: 4px; overflow: hidden; margin-top: 20px; }
    #progressBar { width: 0%; height: 20px; background-color: var(--primary-color); transition: width 0.3s ease-in-out; }
    .comparison-container { position: relative; width: 100%; overflow: hidden; border-radius: 8px; }
    .comparison-container canvas { display: block; width: 100%; height: auto; }
    #outputCanvas { position: absolute; top: 0; left: 0; clip-path: polygon(0 0, 50% 0, 50% 100%, 0 100%); }
    .slider { position: absolute; top: 0; left: 50%; width: 4px; height: 100%; background-color: rgba(255, 255, 255, 0.7); cursor: ew-resize; transform: translateX(-50%); }
    .slider-handle { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; border: 2px solid white; border-radius: 50%; background-color: var(--primary-color); transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: space-evenly; }
    .slider-handle::before, .slider-handle::after { content: ''; width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; }
    .slider-handle::before { border-right: 8px solid var(--on-primary-color); } .slider-handle::after { border-left: 8px solid var(--on-primary-color); }
    .controls { margin-top: 20px; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
    #preProcessState canvas { max-width: 100%; border-radius: 8px; margin-top: 15px; }
    .blur-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 20px; }
  </style>
</head>
<body class="state-loading">

  <div class="container">
    <h1>AI Image Enhancer</h1>

    <div id="loadingState" class="app-state"><p>Loading AI Model...</p><div class="spinner"></div><p id="modelError" style="color: #cf6679; display: none;"></p></div>

    <div id="uploadState" class="app-state">
      <input type="file" id="fileElem" accept="image/*">
      <div id="drop-area"><p>Drag & Drop Image Here</p><p>or</p><label for="fileElem" class="btn">Choose a File</label></div>
    </div>
    
    <div id="preProcessState" class="app-state">
        <p>Your uploaded image:</p>
        <canvas id="preProcessCanvas"></canvas>
        <div class="blur-controls">
            <label for="blurSlider">Blur Radius: <span id="blurValue">0</span>px</label>
            <input type="range" id="blurSlider" min="0" max="10" value="0" step="0.1" style="width: 80%;">
        </div>
        <div class="controls">
            <button id="enhanceBlurredBtn" class="btn">Enhance Blurred Image</button>
            <button id="enhanceOriginalBtn" class="btn">Enhance Original</button>
        </div>
    </div>

    <div id="processingState" class="app-state"><p>Enhancing image, please wait...</p><div id="progressBarContainer"><div id="progressBar"></div></div><p id="progressText">0%</p></div>

    <div id="resultsState" class="app-state">
      <p style="text-align:center;">Slide to compare Before vs. After</p>
      <div class="comparison-container" id="comparisonContainer"><canvas id="inputCanvas"></canvas><canvas id="outputCanvas"></canvas><div class="slider" id="slider"><div class="slider-handle"></div></div></div>
      <div class="controls"><button id="downloadBtn" class="btn">Download Enhanced Image</button><button id="resetBtn" class="btn">Enhance Another</button></div>
    </div>
  </div>

<script>
    const TILE_SIZE = 256;
    const dom = {
        body: document.body, dropArea: document.getElementById('drop-area'), fileElem: document.getElementById('fileElem'),
        progressBar: document.getElementById('progressBar'), progressText: document.getElementById('progressText'),
        modelErrorText: document.getElementById('modelError'), inputCanvas: document.getElementById('inputCanvas'),
        outputCanvas: document.getElementById('outputCanvas'), comparisonContainer: document.getElementById('comparisonContainer'),
        slider: document.getElementById('slider'), downloadBtn: document.getElementById('downloadBtn'), resetBtn: document.getElementById('resetBtn'),
        preProcessCanvas: document.getElementById('preProcessCanvas'), blurSlider: document.getElementById('blurSlider'),
        blurValue: document.getElementById('blurValue'), enhanceBlurredBtn: document.getElementById('enhanceBlurredBtn'),
        enhanceOriginalBtn: document.getElementById('enhanceOriginalBtn')
    };
    let session, originalImage;

    function setAppState(state) { dom.body.className = `state-${state}`; }

    async function initModel() {
      try {
        session = await ort.InferenceSession.create("/Ai-image-enhancer/model.onnx");
        setAppState('upload');
      } catch (error) {
        dom.modelErrorText.textContent = `Error: Failed to load model. Make sure 'model.onnx' is in the same directory as this HTML file and you are running a local server. Details: ${error.message}`;
        dom.modelErrorText.style.display = 'block';
      }
    }

    function getImageTensor(ctx, x, y) {
      const imageData = ctx.getImageData(x, y, TILE_SIZE, TILE_SIZE);
      const { data } = imageData;
      const float32Data = new Float32Array(3 * TILE_SIZE * TILE_SIZE);
      for (let i = 0; i < TILE_SIZE * TILE_SIZE; i++) {
        float32Data[i] = data[i * 4] / 255.0;
        float32Data[i + TILE_SIZE * TILE_SIZE] = data[i * 4 + 1] / 255.0;
        float32Data[i + 2 * TILE_SIZE * TILE_SIZE] = data[i * 4 + 2] / 255.0;
      }
      return new ort.Tensor("float32", float32Data, [1, 3, TILE_SIZE, TILE_SIZE]);
    }

    function putImageTensor(ctx, x, y, tensor) {
      const outputData = tensor.data;
      const imageData = ctx.createImageData(TILE_SIZE, TILE_SIZE);
      for (let i = 0; i < TILE_SIZE * TILE_SIZE; i++) {
        imageData.data[i * 4] = Math.max(0, Math.min(255, outputData[i] * 255));
        imageData.data[i * 4 + 1] = Math.max(0, Math.min(255, outputData[i + TILE_SIZE * TILE_SIZE] * 255));
        imageData.data[i * 4 + 2] = Math.max(0, Math.min(255, outputData[i + 2 * TILE_SIZE * TILE_SIZE] * 255));
        imageData.data[i * 4 + 3] = 255;
      }
      ctx.putImageData(imageData, x, y);
    }

    async function enhanceImage(sourceCanvas) {
        setAppState('processing');
        await new Promise(r => setTimeout(r, 100));

        const originalWidth = sourceCanvas.width;
        const originalHeight = sourceCanvas.height;
        const paddedWidth = Math.ceil(originalWidth / TILE_SIZE) * TILE_SIZE;
        const paddedHeight = Math.ceil(originalHeight / TILE_SIZE) * TILE_SIZE;

        const paddedInputCanvas = document.createElement('canvas');
        paddedInputCanvas.width = paddedWidth;
        paddedInputCanvas.height = paddedHeight;
        const paddedInputCtx = paddedInputCanvas.getContext('2d');
        paddedInputCtx.drawImage(sourceCanvas, 0, 0);

        const paddedOutputCanvas = document.createElement('canvas');
        paddedOutputCanvas.width = paddedWidth;
        paddedOutputCanvas.height = paddedHeight;
        const paddedOutputCtx = paddedOutputCanvas.getContext('2d');

        const totalTiles = (paddedWidth / TILE_SIZE) * (paddedHeight / TILE_SIZE);
        let processedTiles = 0;

        for (let y = 0; y < paddedHeight; y += TILE_SIZE) {
            for (let x = 0; x < paddedWidth; x += TILE_SIZE) {
                const tensor = getImageTensor(paddedInputCtx, x, y);
                const results = await session.run({ input: tensor });
                putImageTensor(paddedOutputCtx, x, y, results.output);

                processedTiles++;
                const progress = Math.round((processedTiles / totalTiles) * 100);
                dom.progressBar.style.width = `${progress}%`;
                dom.progressText.textContent = `${progress}%`;

                // --- THIS IS THE FIX FOR THE PROGRESS BAR ---
                // This line allows the browser to repaint the screen before the next tile.
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
        
        dom.inputCanvas.width = dom.outputCanvas.width = originalWidth;
        dom.inputCanvas.height = dom.outputCanvas.height = originalHeight;
        dom.inputCanvas.getContext('2d').drawImage(sourceCanvas, 0, 0);
        dom.outputCanvas.getContext('2d').drawImage(paddedOutputCanvas, 0, 0, originalWidth, originalHeight, 0, 0, originalWidth, originalHeight);

        setAppState('results');
    }

    function applyBlurPreview() {
        const radius = dom.blurSlider.value;
        dom.blurValue.textContent = radius;
        const ctx = dom.preProcessCanvas.getContext('2d');
        ctx.clearRect(0, 0, dom.preProcessCanvas.width, dom.preProcessCanvas.height);
        ctx.filter = `blur(${radius}px)`;
        ctx.drawImage(originalImage, 0, 0);
        ctx.filter = 'none';
    }

    function handleFiles(files) {
        const file = files[0];
        if (!file || !file.type.startsWith('image/')) return alert('Please upload a valid image file.');
        
        const img = new Image();
        img.onload = () => {
            originalImage = img;
            const ctx = dom.preProcessCanvas.getContext('2d');
            dom.preProcessCanvas.width = img.width;
            dom.preProcessCanvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            dom.blurSlider.value = 0;
            dom.blurValue.textContent = '0';
            setAppState('pre-process');
        };
        img.src = URL.createObjectURL(file);
    }

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eName => dom.dropArea.addEventListener(eName, e => { e.preventDefault(); e.stopPropagation(); }));
    ['dragenter', 'dragover'].forEach(eName => dom.dropArea.addEventListener(eName, () => dom.dropArea.classList.add('highlight')));
    ['dragleave', 'drop'].forEach(eName => dom.dropArea.addEventListener(eName, () => dom.dropArea.classList.remove('highlight')));
    dom.dropArea.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
    dom.fileElem.addEventListener('change', e => handleFiles(e.target.files));
    
    dom.downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'enhanced_image.png';
        link.href = dom.outputCanvas.toDataURL('image/png');
        link.click();
    });

    dom.resetBtn.addEventListener('click', () => {
      setAppState('upload');
      dom.slider.style.left = '50%';
      dom.outputCanvas.style.clipPath = 'polygon(0 0, 50% 0, 50% 100%, 0 100%)';
    });

    dom.blurSlider.addEventListener('input', applyBlurPreview);
    
    dom.enhanceBlurredBtn.addEventListener('click', () => {
        const blurredCanvas = document.createElement('canvas');
        blurredCanvas.width = originalImage.width;
        blurredCanvas.height = originalImage.height;
        const ctx = blurredCanvas.getContext('2d');
        ctx.filter = `blur(${dom.blurSlider.value}px)`;
        ctx.drawImage(originalImage, 0, 0);
        enhanceImage(blurredCanvas);
    });

    dom.enhanceOriginalBtn.addEventListener('click', () => enhanceImage(dom.preProcessCanvas));

    let isDragging = false;
    const moveSlider = (clientX) => {
        if (!isDragging) return;
        const rect = dom.comparisonContainer.getBoundingClientRect();
        let x = clientX - rect.left;
        x = Math.max(0, Math.min(x, rect.width));
        const percent = (x / rect.width) * 100;
        dom.slider.style.left = `${percent}%`;
        dom.outputCanvas.style.clipPath = `polygon(0 0, ${percent}% 0, ${percent}% 100%, 0 100%)`;
    };
    dom.slider.addEventListener('mousedown', () => isDragging = true);
    document.addEventListener('mouseup', () => isDragging = false);
    document.addEventListener('mousemove', e => moveSlider(e.clientX));
    dom.slider.addEventListener('touchstart', e => { isDragging = true; e.preventDefault(); });
    document.addEventListener('touchend', () => isDragging = false);
    document.addEventListener('touchmove', e => moveSlider(e.touches[0].clientX));

    initModel();
  </script>
</body>
</html>